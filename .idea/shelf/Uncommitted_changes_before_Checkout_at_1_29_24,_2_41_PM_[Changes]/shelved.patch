Index: app/src/main/java/com/woleapp/netpos/contactless/viewmodels/AuthViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.woleapp.netpos.contactless.viewmodels\n\nimport android.util.Patterns\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.ViewModel\nimport com.auth0.android.jwt.JWT\nimport com.dsofttech.dprefs.utils.DPrefs\nimport com.google.firebase.messaging.FirebaseMessaging\nimport com.google.gson.Gson\nimport com.google.gson.JsonObject\nimport com.woleapp.netpos.contactless.domain.DataEncryptionAndDecryption\nimport com.woleapp.netpos.contactless.domain.SharedPrefsManagerContract\nimport com.woleapp.netpos.contactless.model.* // ktlint-disable no-wildcard-imports\nimport com.woleapp.netpos.contactless.network.ContactlessRegRepository\nimport com.woleapp.netpos.contactless.network.FwRepository\nimport com.woleapp.netpos.contactless.network.StormApiService\nimport com.woleapp.netpos.contactless.util.* // ktlint-disable no-wildcard-imports\nimport com.woleapp.netpos.contactless.util.AppConstants.RESET_USERNAME\nimport com.woleapp.netpos.contactless.util.AppConstants.STRING_TAG_APP_ENCRYPTION_CREDENTIALS\nimport com.woleapp.netpos.contactless.util.AppConstants.getGUID\nimport com.woleapp.netpos.contactless.util.Mappers.toUser\nimport com.woleapp.netpos.contactless.util.Singletons.gson\nimport com.woleapp.netpos.contactless.util.UtilityParam.STRING_REQ_CRED_CREDENTIALS\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport io.reactivex.Scheduler\nimport io.reactivex.Single\nimport io.reactivex.android.schedulers.AndroidSchedulers\nimport io.reactivex.disposables.CompositeDisposable\nimport io.reactivex.schedulers.Schedulers\nimport org.json.JSONObject\nimport retrofit2.HttpException\nimport timber.log.Timber\nimport javax.inject.Inject\nimport javax.inject.Named\nimport retrofit2.Response\n\n@HiltViewModel\nclass AuthViewModel @Inject constructor() : ViewModel() {\n    @Inject\n    lateinit var fwRepository: FwRepository\n\n    @Inject\n    @Named(\"network-enc\")\n    lateinit var encryptionHelper: DataEncryptionAndDecryption\n\n    @Inject\n    lateinit var contactlessRegRepository: ContactlessRegRepository\n\n    @Inject\n    @Named(\"io-scheduler\")\n    lateinit var ioScheduler: Scheduler\n\n    @Inject\n    @Named(\"main-scheduler\")\n    lateinit var mainThreadScheduler: Scheduler\n\n    @Inject\n    lateinit var compositeDisposable: CompositeDisposable\n\n    @Inject\n    lateinit var sharedPrefs: SharedPrefsManagerContract\n    private val disposables = CompositeDisposable()\n    var stormApiService: StormApiService? = null\n    var appCredentials: JsonObject? = null\n    val authInProgress = MutableLiveData(false)\n    val passwordResetInProgress = MutableLiveData(false)\n    val usernameLiveData = MutableLiveData(\"\")\n    val passwordLiveData = MutableLiveData(\"\")\n    private val _message = MutableLiveData<Event<String>>()\n    private val _authDone = MutableLiveData<Event<Boolean>>()\n    private val _otpReceived = MutableLiveData<Event<Boolean>>()\n    private val _gotoAdminPage = MutableLiveData<Event<Boolean>>()\n    private val _passwordResetSent = MutableLiveData<Event<Boolean>>()\n\n    private lateinit var username: String\n\n    private var otpReference: String? = \"\"\n    private val headerValues = FlwHeaderGenerator.generateHeaders()\n\n    private val _fwKeyHolder: MutableLiveData<Resource<FWKeyHolderDomain>> = MutableLiveData()\n    val fwKeyHolder: LiveData<Resource<FWKeyHolderDomain>> get() = _fwKeyHolder\n    val otpReceived: LiveData<Event<Boolean>> get() = _otpReceived\n    private val _otpVerifyResponse = MutableLiveData<OTPVerifyResponse?>()\n    val otpVerifyResponse: LiveData<OTPVerifyResponse?> = _otpVerifyResponse\n    private lateinit var firebaseToken: String\n\n    val passwordResetSent: LiveData<Event<Boolean>>\n        get() = _passwordResetSent\n\n    val gotoAdminPage: LiveData<Event<Boolean>>\n        get() = _gotoAdminPage\n\n    val authDone: LiveData<Event<Boolean>>\n        get() = _authDone\n\n\n    val message: LiveData<Event<String>>\n        get() = _message\n\n\n    fun flutterWaveOtpRequest() {\n        val username = usernameLiveData.value\n        if (username.isNullOrEmpty()) {\n            _message.value = Event(\"All fields are required\")\n            return\n        }\n        if (!Patterns.EMAIL_ADDRESS.matcher(username).matches()) {\n            _message.value = Event(\"Please enter a valid email\")\n            return\n        }\n\n        this.username = username\n\n\n        fwRepository.run {\n            authInProgress.value = true\n            retrieveOTPAfterSignIn(\n                FWOTPRequest(\n                    headerValues.session,\n                    headerValues.sessionTimeStamp,\n                    headerValues.authorization,\n                    email = username\n                )\n            )\n                .subscribeOn(ioScheduler)\n                .observeOn(mainThreadScheduler)\n                .doFinally { authInProgress.postValue(false) }\n                .subscribe({ response ->\n                    handleSuccessResponseForOtpRequest(Response.success(response))\n                }, { error ->\n                    handleError(error, \"OTP Request Failed\")\n                })\n                .disposeWith(compositeDisposable)\n        }\n    }\n\n\n    fun flwOtpVerification(deviceId: String) {\n        val otpInput = passwordLiveData.value\n        if (otpInput.isNullOrEmpty()) {\n            _message.value = Event(\"OTP Input Required\")\n            return\n        }\n\n        FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->\n            if (!task.isSuccessful) return@addOnCompleteListener\n\n            firebaseToken = task.result // Token retrieved\n            val request = OTPVerifyRequest(\n                headerValues.session,\n                headerValues.sessionTimeStamp,\n                headerValues.authorization,\n                OtpRequestTokens(deviceId, getGUID(), firebaseToken, otpInput, otpReference!!)\n            )\n\n            fwRepository.run {\n                Timber.tag(\"OTP_VERIFY_REQUEST\").d(gson.toJson(request))\n                authInProgress.value = true\n                verifyOTP(request)\n                    .subscribeOn(ioScheduler)\n                    .observeOn(mainThreadScheduler)\n                    .doFinally { authInProgress.postValue(false) }\n                    .subscribe({ handleSuccessResponseForOtpVerification(it) }, { handleError(it, \"OTP Verification Failed\") })\n                    .disposeWith(compositeDisposable)\n            }\n            Timber.tag(\"FCM\").d(firebaseToken)\n        }\n    }\n\n    fun flwResendOtp() {\n        val request = ResendOtpRequest(\n            headerValues.session,\n            headerValues.sessionTimeStamp,\n            headerValues.authorization,\n            OtpReference(otpReference!!)\n        )\n\n        fwRepository.run {\n            authInProgress.value = true\n            resendOTP(request)\n                .subscribeOn(ioScheduler)\n                .observeOn(mainThreadScheduler)\n                .doFinally { authInProgress.postValue(false) }\n                .subscribe({ response ->\n                    handleSuccessResponseForOtpRequest(response)\n                }, { error ->\n                    handleError(error, \"OTP Request Failed\")\n                })\n                .disposeWith(compositeDisposable)\n        }\n    }\n\n    private fun handleSuccessResponseForOtpVerification(response: Response<OTPVerifyResponse>) {\n        if (response.body()?.status == \"success\") {\n            val user = response.body()?.toUser(username)\n            DPrefs.putString(PREF_USER, gson.toJson(user))\n            DPrefs.putLong(PREF_FLW_USER_SAVED_SESSION_TIMESTAMP, System.currentTimeMillis())\n            DPrefs.putBoolean(PREF_AUTHENTICATED, true)\n            _authDone.value = Event(true)\n            Timber.tag(\"OTP_VERIFY\").d(gson.toJson(response))\n        } else {\n            val errorMessage = response.errorBody()?.string() ?: \"Unknown error occurred\"\n            _message.value = Event(\n                try {\n                    gson.fromJson(errorMessage, AuthError::class.java).message ?: \"OTP request failed\"\n                } catch (e: Exception) {\n                    \"OTP request failed\"\n                }\n            )\n        }\n    }\n\n    private fun handleSuccessResponseForOtpRequest(response: Response<FWOTPResponse>) {\n        if (response.body()?.status == \"success\") {\n            val otpReference = response.body()?.data?.otpReference\n            if (otpReference != null) {\n                this@AuthViewModel.otpReference = otpReference\n                _otpReceived.value = Event(true)\n                Timber.tag(\"OTPResponse\").d(otpReference)\n                _message.value = Event(\"OTP Sent to your email and number\")\n            } else {\n                val errorMessage = \"OTP data not found\"\n                _message.value = Event(errorMessage)\n            }\n        } else {\n            val errorMessage = response.body()?.message ?: \"Unknown error occurred\"\n            _message.value = Event(errorMessage)\n        }\n    }\n\n\n    private fun handleError(error: Throwable, message: String) {\n        val errorMessage = when (error) {\n            is HttpException -> {\n                error.response()?.errorBody()?.string() ?: message\n            }\n            else -> \"Network or other error: ${error.localizedMessage}\"\n        }\n        _message.value = Event(\n            try {\n                gson.fromJson(errorMessage, AuthError::class.java).message ?: message\n            } catch (e: Exception) {\n                message\n            }\n        )\n    }\n\n    fun login(deviceSerialId: String) {\n        contactlessRegRepository.getCred(STRING_REQ_CRED_CREDENTIALS)\n            .subscribeOn(ioScheduler)\n            .observeOn(mainThreadScheduler)\n            .subscribe { data, error ->\n                data?.let {\n                    if (it) {\n                        val resp =\n                            sharedPrefs.retrieveString(STRING_TAG_APP_ENCRYPTION_CREDENTIALS, null)\n                        val cred = gson.fromJson(resp, EncryptionCredentials::class.java)\n                        if (cred == null) _message.value = Event(\"Login Failed, please try again!\")\n                    } else {\n                        _message.value = Event(\"Login Failed, please try again!\")\n                    }\n                }\n                error?.let {\n                    Timber.d(it.localizedMessage)\n                    _message.value = Event(\"Login Failed, please try again!\")\n                }\n            }.disposeWith(compositeDisposable)\n\n        val username = usernameLiveData.value\n        val password = passwordLiveData.value\n        if (username.isNullOrEmpty() || password.isNullOrEmpty()) {\n            _message.value = Event(\"All fields are required\")\n            return\n        }\n        if (!Patterns.EMAIL_ADDRESS.matcher(username).matches()) {\n            _message.value = Event(\"Please enter a valid email\")\n            return\n        }\n        auth(username, password)\n    }\n\n    fun flutterWaveSetUp() {\n        _fwKeyHolder.postValue(Resource.loading(null))\n        fwRepository.performFwSetUp()\n            .subscribeOn(ioScheduler)\n            .observeOn(mainThreadScheduler)\n            .subscribe { data, error ->\n                data?.let {\n                    _fwKeyHolder.postValue(Resource.success(it))\n                }\n                error?.let {\n                    _fwKeyHolder.postValue(Resource.error(null))\n                }\n            }.disposeWith(compositeDisposable)\n    }\n\n    private fun auth(username: String, password: String) {\n        authInProgress.value = true\n        val credentials = JsonObject()\n            .apply {\n                addProperty(\"username\", username)\n                addProperty(\"password\", password)\n            }\n        stormApiService!!.userToken(credentials)\n            .flatMap {\n                Timber.e(it.toString())\n                if (!it.success) {\n                    throw Exception(\"Login Failed, Check Credentials\")\n                }\n                val userToken = it.token\n                val stormId: String =\n                    JWTHelper.getStormId(userToken) ?: throw Exception(\"Login Failed\")\n                DPrefs.putString(PREF_USER_TOKEN, userToken)\n                val userTokenDecoded = JWT(userToken)\n                val user = User().apply {\n                    this.netplusPayMid = if (userTokenDecoded.claims.containsKey(\"netplusPayMid\")) {\n                        userTokenDecoded.getClaim(\"netplusPayMid\").asString()\n                    } else {\n                        null\n                    }\n                    this.business_address =\n                        if (userTokenDecoded.claims.containsKey(\"business_address\")) {\n                            userTokenDecoded.getClaim(\n                                \"business_address\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                    this.terminal_id =\n                        if (userTokenDecoded.claims.containsKey(\"terminalId\")) {\n                            userTokenDecoded.getClaim(\n                                \"terminalId\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                    this.business_name =\n                        if (userTokenDecoded.claims.containsKey(\"businessName\")) {\n                            userTokenDecoded.getClaim(\n                                \"businessName\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                    this.netplus_id =\n                        if (userTokenDecoded.claims.containsKey(\"stormId\")) {\n                            userTokenDecoded.getClaim(\n                                \"stormId\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                    this.mid =\n                        if (userTokenDecoded.claims.containsKey(\"mid\")) {\n                            userTokenDecoded.getClaim(\"mid\")\n                                .asString()\n                        } else {\n                            \" \"\n                        }\n                    this.partnerId =\n                        if (userTokenDecoded.claims.containsKey(\"partnerId\")) {\n                            userTokenDecoded.getClaim(\n                                \"partnerId\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                    this.email =\n                        if (userTokenDecoded.claims.containsKey(\"email\")) {\n                            userTokenDecoded.getClaim(\n                                \"email\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                    this.userType =\n                        if (userTokenDecoded.claims.containsKey(\"user_type\")) {\n                            userTokenDecoded.getClaim(\n                                \"user_type\",\n                            ).asString()\n                        } else {\n                            \" \"\n                        }\n                }\n\n                Timber.tag(\"LoggedInUser==>\").d(gson.toJson(user))\n                Single.just(user)\n            }.subscribeOn(Schedulers.io())\n            .doFinally { authInProgress.postValue(false) }\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe { res, error ->\n                res?.let {\n                    DPrefs.putString(PREF_USER, gson.toJson(it))\n                    DPrefs.putBoolean(PREF_AUTHENTICATED, true)\n                    _authDone.value = Event(true)\n                }\n                error?.let {\n                    Timber.e(it)\n                    if (it.message.equals(\"admin\", true)) {\n                        _gotoAdminPage.value = Event(true)\n                        return@let\n                    }\n                    Timber.e(it.localizedMessage)\n                    (it as? HttpException).let { httpException ->\n                        val errorMessage = httpException?.response()?.errorBody()?.string()\n                            ?: \"{\\\"success\\\":false,\\\"message\\\":\\\"Unexpected error\\\"}\"\n                        _message.value = Event(\n                            try {\n                                gson.fromJson(errorMessage, AuthError::class.java).message\n                                    ?: \"Login Failed\"\n                            } catch (e: Exception) {\n                                \"login failed\"\n                            },\n                        )\n                        Timber.e(errorMessage)\n                    }\n                }\n            }.disposeWith(disposables)\n    }\n\n    fun resetPassword() {\n        val username = usernameLiveData.value\n        if (username.isNullOrEmpty()) {\n            _message.value = Event(\"Please enter your email address\")\n            return\n        }\n\n        val payload = JsonObject().apply {\n            addProperty(\"username\", username)\n        }\n        DPrefs.putString(RESET_USERNAME, username)\n        stormApiService!!.passwordReset(payload).subscribeOn(Schedulers.io())\n            .doOnSubscribe {\n                passwordResetInProgress.postValue(true)\n            }.doFinally { passwordResetInProgress.postValue(false) }\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe { t1, t2 ->\n                t1?.let {\n                    _message.value = if (it.code() != 200) {\n                        Event(\"Password reset failed\")\n                    } else {\n                        val res = JSONObject(Gson().toJson(it.body()))\n                        if (!res.getBoolean(\"success\")) {\n                            Event(\"Password reset failed\")\n                        } else {\n                            _passwordResetSent.value = Event(true)\n                            Event(\"A password reset mail has been sent to $username\")\n                        }\n                    }\n                }\n                t2?.let {\n                    _message.value = Event(\"Password reset failed, try again.\")\n                }\n            }.disposeWith(disposables)\n    }\n\n    fun resetPasswordForFCMB(partnerID: String, deviceId: String) {\n        val username = usernameLiveData.value\n        val password = passwordLiveData.value\n        if (username.isNullOrEmpty() || password.isNullOrEmpty()) {\n            _message.value = Event(\"All fields are required\")\n            return\n        }\n\n        val payload = JsonObject().apply {\n            addProperty(\"username\", username)\n            addProperty(\"password\", password)\n        }\n        // DPrefs.putString(RESET_USERNAME, username)\n        stormApiService!!.passwordResetForProvidus(payload, partnerID, deviceId)\n            .subscribeOn(Schedulers.io())\n            .doOnSubscribe {\n                passwordResetInProgress.postValue(true)\n            }.doFinally { passwordResetInProgress.postValue(false) }\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe { t1, t2 ->\n                t1?.let {\n                    _message.value = if (it.code() != 200) {\n                        Event(\"Email address not associated with this device. Please contact administrator\")\n                    } else {\n                        val res = JSONObject(Gson().toJson(it.body()))\n                        if (!res.getBoolean(\"success\")) {\n                            Event(\"Password reset failed\")\n                        } else {\n                            _passwordResetSent.value = Event(true)\n                            Event(\"Password reset successfully!\")\n                        }\n                    }\n                }\n                t2?.let {\n                    Timber.d(\"ERROR==${it.localizedMessage}\")\n                    (it as? HttpException).let { httpException ->\n                        val errorMessage = httpException?.response()?.errorBody()?.string()\n                            ?: \"{\\\"message\\\":\\\"Unexpected error\\\"}\"\n                        _message.value = Event(\n                            try {\n                                gson.fromJson(errorMessage, GeneralResponse::class.java).message\n                                    ?: \"Error\"\n                            } catch (e: Exception) {\n                                \"Error\"\n                            },\n                        )\n                        // Timber.e(\"SHOWME--->$errorMessage\")\n                    }\n                }\n            }.disposeWith(disposables)\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        disposables.clear()\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/woleapp/netpos/contactless/viewmodels/AuthViewModel.kt b/app/src/main/java/com/woleapp/netpos/contactless/viewmodels/AuthViewModel.kt
--- a/app/src/main/java/com/woleapp/netpos/contactless/viewmodels/AuthViewModel.kt	
+++ b/app/src/main/java/com/woleapp/netpos/contactless/viewmodels/AuthViewModel.kt	
@@ -218,7 +218,7 @@
                 this@AuthViewModel.otpReference = otpReference
                 _otpReceived.value = Event(true)
                 Timber.tag("OTPResponse").d(otpReference)
-                _message.value = Event("OTP Sent to your email and number")
+                _message.value = Event("An OTP has been sent to your email and number")
             } else {
                 val errorMessage = "OTP data not found"
                 _message.value = Event(errorMessage)
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>apply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-kapt'\napply plugin: 'kotlin-parcelize'\napply plugin: 'dagger.hilt.android.plugin'\napply plugin: 'com.google.gms.google-services'\n\n\ndef appPropertiesFile = rootProject.file(\"app-settings.properties\")\ndef appProperties = new Properties()\nappProperties.load(new FileInputStream(appPropertiesFile))\ndef appModeProd = appProperties[\"env.use.mode.production\"]\n\ndef keystorePropertiesFile = rootProject.file(\"keystore.properties\")\ndef keystoreProperties = new Properties()\nkeystoreProperties.load(new FileInputStream(keystorePropertiesFile))\n\n\ndef localPropertiesFile = rootProject.file(\"local.properties\")\ndef localProperties = new Properties()\nlocalProperties.load(new FileInputStream(localPropertiesFile))\n\nandroid {\n    signingConfigs {\n        netpos_signing_config {\n            keyAlias keystoreProperties['keyAlias']\n            keyPassword keystoreProperties['keyPassword']\n            storeFile file(keystoreProperties['storeFile'])\n            storePassword keystoreProperties['storePassword']\n            enableV1Signing false\n        }\n    }\n    compileSdkVersion 34\n    buildFeatures.dataBinding = true\n    ndkVersion \"21.3.6528147\"\n    defaultConfig {\n        configurations.all {\n            resolutionStrategy { force 'androidx.core:core-ktx:1.6.0' }\n        }\n        resValue \"string\", \"app_name\", \"NetPOS Contactless\"\n        vectorDrawables.useSupportLibrary = true\n        applicationId \"com.woleapp.netpos.contactless\"\n        compileSdkVersion 34\n        minSdkVersion 24\n        targetSdkVersion 34\n        versionCode 39\n        versionName \"1.0.39\"\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n        def environmentPath\n        if (appModeProd == \"true\") environmentPath = appProperties[\"env.path.production\"] else environmentPath = appProperties[\"env.path.staging\"]\n        buildConfigField \"Boolean\", \"APPMODE_PROD\", appModeProd\n    }\n\n    dataBinding {\n        enabled = true\n    }\n\n    buildTypes {\n        debug {\n            signingConfig signingConfigs.netpos_signing_config\n            buildConfigField \"String\", \"BUILD_VARIANT\", \"\\\"debug\\\"\"\n            buildConfigField \"boolean\", \"DEBUG\", \"true\"\n            ndk {\n                abiFilters \"armeabi-v7a\", \"x86\", \"x86_64\"\n            }\n            resValue \"string\", \"app_name\", \"NetPOS Debug\"\n            applicationIdSuffix \".debug\"\n        }\n        release {\n            signingConfig signingConfigs.netpos_signing_config\n            buildConfigField \"String\", \"BUILD_VARIANT\", \"\\\"release\\\"\"\n            resValue \"string\", \"app_name\", \"NetPOS Contactless\"\n            buildConfigField \"boolean\", \"DEBUG\", \"false\"\n            debuggable false\n            minifyEnabled false\n            shrinkResources false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n        nibssserverdebug {\n            initWith debug\n            buildConfigField \"String\", \"BUILD_VARIANT\", \"\\\"nibssServerDebug\\\"\"\n            resValue \"string\", \"app_name\", \"Admin Debug\"\n            applicationIdSuffix \".debugserver\"\n        }\n        releaseAdmin {\n            initWith release\n            buildConfigField \"String\", \"BUILD_VARIANT\", \"\\\"releaseAdmin\\\"\"\n            resValue \"string\", \"app_name\", \"Admin NetPOS\"\n            applicationIdSuffix \".releaseAdmin\"\n        }\n    }\n\n    flavorDimensions \"whiteLabel\"\n    productFlavors {\n        netpos {\n            dimension \"whiteLabel\"\n        }\n        firstbank {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".firstbank\"\n        }\n        providus {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".providus\"\n        }\n        providuspos {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".providuspos\"\n        }\n        providussoftpos {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".providussoftpos\"\n        }\n        wemabank {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".wemabank\"\n        }\n        easypay {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".easypay\"\n        }\n        fcmbeasypay {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".fcmbeasypay\"\n        }\n        zenith {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".zenith\"\n        }\n        unitybank {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".unitybank\"\n        }\n        polaris {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".polaris\"\n        }\n        stanbic {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".stanbic\"\n        }\n        flutterwave {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".flutterwave\"\n            String flwAuthSecretTest = localProperties.getProperty(\"FLW_SOFTPOS_AUTH_SECRET_SHARED_TEST\")\n            buildConfigField \"String\", \"FLW_SOFTPOS_AUTH_SECRET_SHARED_TEST\", \"${flwAuthSecretTest}\"\n        }\n        tingo {\n            dimension \"whiteLabel\"\n            applicationIdSuffix \".tingo\"\n        }\n    }\n    variantFilter { variant ->\n        def name_types = variant.flavors*.name\n        def name = name_types.join()\n        if (variant.buildType.name == \"release\" && name.contains(\"nibssserverdebug\") || variant.buildType.name == \"release\" && name.contains(\"releaseAdmin\")) {\n            setIgnore(true)\n        }\n        if (variant.buildType.name == \"debug\" && name.contains(\"nibssserverdebug\") || variant.buildType.name == \"debug\" && name.contains(\"releaseAdmin\")) {\n            setIgnore(true)\n        }\n    }\n\n    sourceSets {\n        netpos {\n            java.srcDirs('src/default/java')\n        }\n        firstbank {\n            java.srcDirs('src/default/java')\n        }\n        providus {\n            java.srcDirs('src/default/java')\n        }\n    }\n\n    compileOptions {\n        coreLibraryDesugaringEnabled true\n        targetCompatibility JavaVersion.VERSION_1_8\n        sourceCompatibility JavaVersion.VERSION_1_8\n    }\n    packagingOptions {\n        exclude 'META-INF/INDEX.LIST'\n        exclude 'META-INF/io.netty.versions.properties'\n        exclude 'META-INF/DEPENDENCIES'\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n    ndkVersion '21.3.6528147'\n    externalNativeBuild {\n        ndkBuild {\n            path file('src/main/jni/Android.mk')\n        }\n    }\n}\n\ndependencies {\n    def lottieVersion = \"5.2.0\"\n\n    implementation fileTree(include: ['*.jar', '*.aar'], dir: 'libs')\n    coreLibraryDesugaring 'com.android.tools:desugar_jdk_libs:1.1.5'\n    implementation(\"commons-codec:commons-codec:1.15\")\n    implementation(\"commons-lang:commons-lang:2.6\")\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-common:$kotlin_version\"\n    implementation 'androidx.appcompat:appcompat:1.6.1'\n    implementation 'androidx.core:core-ktx:1.10.1'\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'\n    implementation 'com.google.android.material:material:1.9.0'\n    implementation 'androidx.fragment:fragment-ktx:1.4.0'\n    implementation \"androidx.swiperefreshlayout:swiperefreshlayout:1.1.0\"\n\n    //JWT\n    implementation 'io.jsonwebtoken:jjwt-api:0.11.2'\n    implementation 'io.jsonwebtoken:jjwt-impl:0.11.2'\n    implementation 'io.jsonwebtoken:jjwt-jackson:0.11.2'\n    implementation 'com.auth0:java-jwt:3.19.1'\n\n    //rx\n    implementation 'io.reactivex.rxjava2:rxjava:2.2.21'\n    implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'\n    implementation \"io.reactivex.rxjava2:rxkotlin:2.4.0\"\n\n    //epms\n    implementation 'net.sf.j8583:j8583:1.12.0'\n    implementation project(path: ':epmslib-release')\n\n    //Timber\n    implementation 'com.jakewharton.timber:timber:4.7.1'\n\n    //android lifecycle components\n//    implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\"\n//    implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version\"\n//    implementation \"androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version\"\n//    implementation \"androidx.lifecycle:lifecycle-common-java8:$lifecycle_version\"\n//    implementation \"androidx.lifecycle:lifecycle-process:$lifecycle_version\"\n\n    implementation \"android.arch.lifecycle:extensions:1.1.0\"\n    kapt \"android.arch.lifecycle:compiler:1.1.0\"\n\n    //room\n    implementation \"androidx.room:room-runtime:$room_version\"\n    kapt \"androidx.room:room-compiler:$room_version\"\n    implementation \"androidx.room:room-rxjava2:$room_version\"\n\n\n    // OTP VIEWS\n    implementation \"io.github.chaosleung:pinview:$pin_view\"\n\n    // BarCode Scanner Library\n    implementation 'com.github.yuriy-budiyev:code-scanner:2.3.2'\n\n    //retrofit\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'\n    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'\n    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'\n    implementation(\"com.squareup.okhttp3:logging-interceptor:4.9.0\")\n\n    // Hilt\n    implementation \"com.google.dagger:hilt-android:2.42\"\n    kapt \"com.google.dagger:hilt-compiler:2.42\"\n\n    //For AssistedFactory\n    implementation 'com.squareup.inject:assisted-inject-annotations-dagger2:0.5.2'\n    kapt 'com.squareup.inject:assisted-inject-processor-dagger2:0.5.2'\n\n    // For viewModel\n    kapt \"androidx.hilt:hilt-compiler:1.0.0-alpha03\"\n//    implementation \"androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha03\"\n//    kapt \"androidx.hilt:hilt-compiler:1.0.0\"\n\n    // Activity KTX for viewModels()\n    implementation \"androidx.activity:activity-ktx:1.7.0\"\n\n    // Lifecycles only (without ViewModel or LiveData)\n    //  implementation \"androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version\"\n\n    // Google vision\n    implementation 'com.google.android.gms:play-services-vision:20.1.3'\n\n    // DPrefs\n    implementation \"com.github.D-Soft-Tech:DPrefs:1.0.4\"\n\n    //JWT\n    implementation 'com.auth0:java-jwt:3.10.0'\n    implementation 'com.auth0.android:jwtdecode:2.0.0'\n\n    //viewpager2\n    implementation 'androidx.viewpager2:viewpager2:1.0.0'\n\n    //MQTT\n    implementation 'com.hivemq:hivemq-mqtt-client:1.2.1'\n    implementation \"com.hivemq:hivemq-mqtt-client-websocket:1.2.1\"\n    implementation 'net.sourceforge.streamsupport:android-retrostreams:1.7.2'\n    implementation 'net.sourceforge.streamsupport:android-retrofuture:1.7.2'\n\n    implementation 'pub.devrel:easypermissions:3.0.0'\n    implementation 'com.google.zxing:core:3.4.1'\n\n    //glide\n    implementation 'com.github.bumptech.glide:glide:4.12.0'\n    kapt 'com.github.bumptech.glide:compiler:4.11.0'\n\n    //paging\n    implementation \"androidx.paging:paging-runtime:2.1.2\"\n\n    //preference\n    implementation(\"androidx.preference:preference-ktx:1.2.0\")\n\n    //lottie\n    implementation 'com.airbnb.android:lottie:5.2.0'\n\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.3'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'\n    debugImplementation 'com.amitshekhar.android:debug-db:1.0.6'\n\n    // Lootie\n    implementation \"com.airbnb.android:lottie:$lottieVersion\"\n\n    implementation 'com.google.firebase:firebase-messaging-ktx:23.0.8'\n\n    //pdf viewer\n    implementation 'com.github.barteksc:android-pdf-viewer:2.8.2'\n\n    //workmanager\n    def work_version = \"2.9.0-beta01\"\n    implementation \"androidx.work:work-runtime-ktx:$work_version\"\n\n    //barcode\n    implementation 'com.google.android.gms:play-services-vision:20.1.3'\n\n    // Firebase\n    implementation platform('com.google.firebase:firebase-bom:30.4.1')\n    implementation 'com.google.firebase:firebase-analytics-ktx'\n    implementation 'com.google.firebase:firebase-messaging-ktx'\n    implementation 'com.google.firebase:firebase-analytics-ktx'\n\n    // DPrefs\n    implementation 'com.github.D-Soft-Tech:DPrefs:1.0.4'\n    implementation \"org.jetbrains.kotlin:kotlin-reflect:1.8.10\"\n\n    // App Update\n    // implementation \"com.google.android.play:app-update:2.1.0\"\n    // implementation \"com.google.android.play:app-update-ktx:2.1.0\"\n    implementation 'org.bouncycastle:bcpkix-jdk15on:1.67'\n    implementation 'org.jpos:jpos:2.1.6'\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle b/app/build.gradle
--- a/app/build.gradle	
+++ b/app/build.gradle	
@@ -66,6 +66,8 @@
             }
             resValue "string", "app_name", "NetPOS Debug"
             applicationIdSuffix ".debug"
+
+            minifyEnabled false
         }
         release {
             signingConfig signingConfigs.netpos_signing_config
@@ -145,6 +147,7 @@
             applicationIdSuffix ".flutterwave"
             String flwAuthSecretTest = localProperties.getProperty("FLW_SOFTPOS_AUTH_SECRET_SHARED_TEST")
             buildConfigField "String", "FLW_SOFTPOS_AUTH_SECRET_SHARED_TEST", "${flwAuthSecretTest}"
+//            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
         }
         tingo {
             dimension "whiteLabel"
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Project-wide Gradle settings.\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx1536m\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. More details, visit\n# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n# org.gradle.parallel=true\n# AndroidX package structure to make it clearer which packages are bundled with the\n# Android operating system, and which are packaged with your app's APK\n# https://developer.android.com/topic/libraries/support-library/androidx-rn\nandroid.useAndroidX=true\n# Automatically convert third-party libraries to use AndroidX\nandroid.enableJetifier=true\n# Kotlin code style for this project: \"official\" or \"obsolete\":\nkotlin.code.style=official\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/gradle.properties b/gradle.properties
--- a/gradle.properties	
+++ b/gradle.properties	
@@ -6,7 +6,7 @@
 # http://www.gradle.org/docs/current/userguide/build_environment.html
 # Specifies the JVM arguments used for the daemon process.
 # The setting is particularly useful for tweaking memory settings.
-org.gradle.jvmargs=-Xmx1536m
+org.gradle.jvmargs=-Xmx2048m
 # When configured, Gradle will run in incubating parallel mode.
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
